use std::rc::Rc;

pub fn lesson() {
    println!("##### section6だよ");

    /*
    スタックとヒープ

    ■メモリの種類
    テキスト領域：機械語に翻訳されたプログラム
    静的領域：constや文字列リテラルなどの静的変数
    スタック領域：一時データ(ローカル変数、関数の引数など)
    ヒープ領域：コンパイル時にサイズが確定できない動的に変化するデータ(String, Vectorなど)

    ■スタック領域の特徴
    ・ローカル変数や関数の引数などの一時データを格納
    ・コンパイル時にサイズが確定している必要がある
    ・LIFOのシンプルな構造
    ・アクセスが高速
    ・格納できる容量に限りがある(Rustは8MB) 容量を超えて格納しようとするとスタックオーバーフロー

    ■Last in First Out
    ・確保した順とは逆順に使っていく方法
    関数の先頭で宣言した変数の順番に、スタック領域の最初から積んでいく。funcA() -> funcB() -> funcC() 実行が終わると後ろから解放

    ■ヒープ領域
    ・動的なデータを格納できる
    ・コンパイル時にサイズ確定が不要
    ・ヒープに格納されたデータのアドレスを指すポインタや確保しているサイズをスタックに格納するといった複雑な構造
    ・スタックと比べるとアクセスが低速
    ・メモリ管理に課題があった。C言語だとプログラムですべて管理必要。その後GC、代わりに実行速度が遅くなる。Java, Python, Go

    所有権
    ■メモリ管理の課題
    ・プログラマが責任を持って確保都会法を行う方法
        - 柔軟なメモリ管理
        - メモリリーク、二重解放などのバグの可能性が高まる
    ・プログラムが責任を持って確保と解放を行う方法 GC
        - メモリを安全に管理できる
        - メモリ管理にコストが掛かる・チューニングが困難

    ■所有権
    ・Rustがメモリ管理のために採用する仕組み
    ・メモリ上に存在する値を変数が所有するという考え方
    ・所有権の移動や借用が行われる
    ・コンパイル時に所有権のチェックが行われる -> コンパイルの時点でメモリに関するエラーを防ぐ事が可能

    ■所有権の3つのルール
    ・ルール1：Rustの各値は、所有者と呼ばれる変数に対応
    ・ルール2：いかなるときも所有者はひとつ
    ・ルール3：所有者がスコープを外れたら、値は破棄される {}や関数の最後をすぎると破棄。

    ■所有権のルールの例
    let v2 = v1; とした時点で所有権移動。

    ■所有権によって解決できる課題
    ・メモリの開放忘れによるメモリリーク
        - 変数がスコープを抜ける際に値を破棄することでメモリの開放忘れを防ぐ
    ・メモリの多重解放
        - 値の所有者は必ずひとつ、スコープを抜けて破棄されるのh1回のみであるため、起こり得ない
    ・ダングリングポインタ (解放済みのメモリにアクセス)
        - メモリの生存期間は変数のスコープと同じになる。コンパイル時に確定する。生存期間を超えて参照した場合、コンパイルエラーが発生
    ・ガベージコレクションのような複雑な処理を行っていないため、高いパフォーマンスが期待できる。

    所有権の移動
    ■所有権の移動
    let mut v1 = vec![1, 2, 3]; を宣言すると...
    スタック領域
    name: ptr value: ヒープ領域の先頭アドレス
    name: len value: 3
    name:capacity: value: 4 ヒープ領域にどれだけ確保したか。実行環境によって佐賀ある

    ヒープ領域
    index:0 value: 1
    index:1 value: 2
    index:2 value: 3
    index:空 value: 空 ここに入るとさらにcapacityが拡張される。

    もしv2 = v1 と宣言した際に新たなヒープ領域にコピーする方式だと、大きな値の時に困るので採用していない。
    同様に同一のヒープ領域をv1とv2が両方とも指す方式だと、メモリ管理が複雑、ダングリングポインタになるので採用していない。
    v2 = v1 とした時点で所有権が移動、v1からはアクセスできなくなり、未初期化状態に戻る。

    ■移動の例外
    ・Rustには値をコピーするための方法も用意されている。
        - cloneメソッドを使用するとコピー。 v2 = v1.clone();
    ・コピー元のサイズは問題ないかなど、使用には注意が必要。

    ■移動の例外
    ・数値型、論理型などスタックに格納される値ではコピー。
        - コンパイル時に値が決定、値をコピーしても十分高速と保証できるから。
    ・Copyトレイトを実装した型は移動ではなくコピーが行われる。
        - 整数型・浮動小数点型
        - 論理型
        - 文字型
        - タプル(要素がすべてCopy型の場合のみ)

    ■所有権と関数
    ・関数で所有権が移動するケース
        - 変数を別の関数の引数に渡したとき concat(s1, s2);  呼んだあとでs1, s2にアクセスするとエラー。未初期化状態に戻る
        - 関数の戻り地で返ってきた変数
            concat関数の戻り値は1つだが、タプルの()に詰めて複数可能。ここでs1, s2を戻すと使える。ただ戻り値の数がどんどん増えてしまう





    */
    idou();
    sanshou();
    lifetime();
    smart_pointer();
}

pub fn idou() {
    let mut v1 = vec![1, 2, 3];
    println!("v1 ptr: {:?}", v1.as_ptr()); // v1 ptr: 0x7f864b004080  14桁
    println!("v1[0] ptr: {:p}", &v1[0]); // v1[0] ptr: 0x7f864b004080  先頭の要素のアドレス
    println!("v1 len: {}", v1.len()); // v1 len: 3
    println!("v1 capacity: {}", v1.capacity()); // v1 capacity: 3

    v1.push(4); // ちなみにこれがないと、mutにする必要がないよとコンパイラが教えてくれる。すごい。
    println!("v1.push(4)したよ");
    println!("v1 ptr: {:?}", v1.as_ptr()); // v1 ptr: 0x7f864b004080 講義だと別の場所に値を移動、アドレスが変わった
    println!("v1[0] ptr: {:p}", &v1[0]); // v1[0] ptr: 0x7f864b004080
    println!("v1 len: {}", v1.len()); // v1 len: 4
    println!("v1 capacity: {}", v1.capacity()); // v1 capacity: 6

    let v2 = v1;
    //println!("v1 ptr: {:?}", v1.as_ptr()); // borrow of moved value: `v1` 所有権がすでに移っている
    println!("v2 ptr: {:?}", v2.as_ptr()); // v2 ptr: 0x7f864b004080 v1と同じアドレスを指している。
    let v3 = v2.clone();
    println!("v3 ptr: {:?}", v3.as_ptr()); // v3 ptr: 0x7ff5bd0040a0 コピーなので違うアドレスを指している。

    println!("---------------");
    let s1 = String::from("Hello");
    let s2 = String::from("Rust");
    let s = concat(s1, s2); // VSCode上は concat(a: s1, b:s2); と表示。a: b: は実際のコードにはない
    println!("concat結果 {}", s);
    //println!("concat結果 {}", s1); // 移動しているのでs1とs2は使えない。
    //println!("concat結果 {}", s2);

    let s1_tupple = String::from("Hello");
    let s2_tupple = String::from("Rust");
    let s_tupple = concat_tupple(s1_tupple, s2_tupple); // VSCode上は concat(a: s1, b:s2); と表示。a: b: は実際のコードにはない
    println!("concat結果 {:?}", s_tupple);
}

fn concat(a: String, b: String) -> String {
    let c = format!("{}, {}", a, b);
    c
}

fn concat_tupple(a: String, b: String) -> (String, String, String) {
    let c = format!("{}, {}", a, b);
    (c, a, b)
}

fn sanshou() {
    /*
    ■参照とは
    ・所有権を持たないポインタ
        - 値を代入しても所有権が移動しない
        - 所有権を持たないので、値の生存期間に影響を与えない
    ・変数に & 記号をつけることで作成される
    ・参照の型は通常の型に & 記号がついた形になる
    ・ある値の参照をつくることを「借用する」という 権利を借りるだけ。
    ・参照に * をつけることで、参照の実体にアクセス可能。「参照外し」と呼ぶ。

    ■参照の種類
    ・共有参照
        - 参照先を読むことはできるが、変更は不可
        - 変数に&記号をつけることで作成。値vに対する共有参照は &v
        - 同時に複数作成することが可能
    ・可変参照
        - 値の読み出しと変更が可能
        - 変数に&mutをつけることで作成 値vに対する可変参照は &mut v
        - ある値に対する可変参照が存在する場合、その他の参照は作成不可

    */

    println!("--------------- 参照を使うバージョン");
    let s1 = String::from("Hello");
    let s2 = String::from("Rust");
    let s = concat_refer(&s1, &s2); // s1, s2を共有参照で渡す
    println!("concat_refer結果 {}", s);
    println!("concat_refer結果 {}", s1); // 移動していたらs1とs2は使えないが、参照ならOK！
    println!("concat_refer結果 {}", s2);
}

fn concat_refer(a: &String, b: &String) -> String {
    let c = format!("{}, {}", a, b);
    c
}

fn lifetime() {
    /*
    ■ライフタイプとは
    ・参照が有効になるスコープ
        - 参照はすべてライフタイムを保持している
    ・多くの場合、ライフタイムも推論される
    ・ダングリングポインタを防ぐ目的で使用される

    {}内でxを宣言、r= &x として{}の外でrを使用するとコンパイルエラー。使えるとダングリングポインタになってしまう。

    ■参照の成約
    ・変数の生存期間は、その変数から借用した参照の生存期間を包含していなければならない

    ■ライフタイムパラメータ
    ・ライフタイムは推論によって省略されている
    ・省略せずに書く場合、ライフタイプパラメータを 'a のように書ける。
        - tick A (てぃっく・えー) と発音し、任意の生存期間'aを持つ参照という意味になる。aやbがよく使われる。

    fn func_sample<'a>(p: &'a i32) {
        // ...
    }

    あまり出てこないが、コードリーディングの時に必要になったり。


    */
}

fn smart_pointer() {
    println!("--------------- スマートポインタ");
    /*
    通常のポインタに機能を追加したもの
    ボックス：値をヒープ領域に格納

    */
    let x = Box::new(1);
    println!("box x: {:p}", x); //box x: 0x7f89558040a0 //i32は数値型だからスタック領域に直接入るはずが、アドレスのあるヒープ領域に入る！
    println!("*x + 2 = {}", *x + 2020); // x + 2 = 2021 *で参照外しをすると実体にアクセス、計算で使える

    // コンパイル時に値を決定できずにコンパイルエラーとなるものに使う。

    /*
    RC: 所有者を複数にしつつ

    */
    let a = Rc::new("Hello".to_string());
    println!("aの所有者の数: {}", Rc::strong_count(&a)); //aの所有者の数: 1  &aを渡すと所有者の数がわかる
    {
        let b = Rc::clone(&a);
        println!("aのアドレス: {:p}", a); //
        println!("bのアドレス: {:p}", b); // 同じになる
        println!("aの所有者の数: {}", Rc::strong_count(&a)); //aの所有者の数: 2
    }
    println!("aの所有者の数: {}", Rc::strong_count(&a)); //aの所有者の数: 1  bのスコープが終わるので1に戻る。
}
